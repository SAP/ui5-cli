const log = require("@ui5/logger").getLogger("cli:commands:build");

/**
 * Creates a list of dependencies as String or RegExp by processing the given <code>dependencies</code> and
 * <code>dependenciesRegExp</code> parameters. Dependencies are only added to the list if they exist in the
 * project <code>tree</code>. Optionally, also the sub-dependencies of given <code>dependencies</code> are
 * added to the list.
 *
 * @param {object} parameters Parameters
 * @param {object} parameters.tree Project tree as generated by the
 *   [@ui5/project.normalizer]{@link module:@ui5/project.normalizer}
 * @param {Array.<string>} parameters.dependencies The dependencies to be considered
 * @param {Array.<string>} [parameters.dependenciesRegExp] The dependencies to be considered as new
 *   RegExp instances
 * @param {boolean} [parameters.handleSubtree] Decides whether the sub-dependencies of the given
 *   dependencies are included into the returned dependency list
 * @returns {Array.<string>} Array of the computed dependencies
 */
function createDependencyList({tree, dependencies = [], dependenciesRegExp = [], handleSubtree}) {
	const dependencyList = [];

	function _addUnique(depName) {
		if (!dependencyList.includes(depName)) {
			dependencyList.push(depName);
		}
	}
	function _processSubtree(project) {
		project.dependencies.forEach((project0) => {
			_addUnique(project0.metadata.name);
			_processSubtree(project0);
		});
	}

	dependencies.forEach((depName) => {
		if (depName === "*") {
			return _addUnique(depName);
		}
		const project = tree.dependencies.find((dep) => dep.metadata.name === depName);
		if (project) {
			_addUnique(depName);
			if (handleSubtree) {
				_processSubtree(project);
			}
		} else {
			log.warn(`Could not find dependency '${depName}' for '${tree.metadata.name}'.`);
		}
	});

	return dependencyList.concat(dependenciesRegExp.map((exp) => new RegExp(exp)));
}

/**
 * Merges a <code>dependencyList</code> into a <code>targetDependencyList</code> without duplicates. Values
 * given in <code>excludeList</code> are skipped from this operation.
 *
 * @param {Array.<string>} targetDependencyList The target list
 * @param {Array.<string>} dependencyList The source list
 * @param {Array.<string>} excludeList The list of values to be excluded from the merge operation
 */
function mergeDependencyLists(targetDependencyList, dependencyList, excludeList) {
	function isDepIncluded(depList, depName) {
		return depList.some((dep) => dep instanceof RegExp ? dep.test(depName) : dep === depName);
	}
	dependencyList.forEach((dep) => {
		if (!isDepIncluded(targetDependencyList, dep) && !isDepIncluded(excludeList, dep)) {
			targetDependencyList.push(dep);
		}
	});
}

/**
 * Returns whether project dependencies have to be built influenced by <code>includedDependencies</code> and
 * <code>excludedDependencies</code>.
 * In case not all but selected dependencies (via <code>includedDependencies</code>) have to be built, the
 * "*" sign is added to the <code>excludedDependencies</code> to make sure that all other dependencies are
 * excluded.
 * In case a "*" sign is included in <code>includedDependencies</code>, the "*" is removed and the
 * <code>buildAll</code> flag is set to <code>true</code> because it behaves as an alias.
 *
 * @param {boolean} buildAll The value of the <code>all</code> command line parameter to decide if project
 *   dependencies have to be built
 * @param {Array.<string>} includedDependencies The list of included dependencies
 * @param {Array.<string>} excludedDependencies The list of excluded dependencies
 * @returns {boolean} Whether it is required to build project dependencies
 */
function alignWithBuilderAPI(buildAll, includedDependencies, excludedDependencies) {
	if ((!buildAll && !includedDependencies.includes("*")) && includedDependencies.length) {
		excludedDependencies.push("*");
	}
	if (includedDependencies.includes("*")) {
		buildAll = true;
		includedDependencies.splice(includedDependencies.indexOf("*"), 1);
	}
	if (!buildAll && includedDependencies.length) {
		buildAll = true;
	}
	return buildAll;
}

module.exports = {
	createDependencyList,
	mergeDependencyLists,
	alignWithBuilderAPI
};
