const log = require("@ui5/logger").getLogger("cli:utils:buildHelper");

/**
 * Creates a list of dependencies as String or RegExp by processing the given <code>dependencies</code> and
 * <code>dependenciesRegExp</code> parameters. Dependencies are only added to the list if they exist in the
 * project <code>tree</code>. Optionally, also the sub-dependencies of given <code>dependencies</code> are
 * added to the list.
 *
 * @param {object} parameters Parameters
 * @param {object} parameters.tree Project tree as generated by the
 *   [@ui5/project.normalizer]{@link module:@ui5/project.normalizer}
 * @param {Array.<string>} parameters.dependencies The dependencies to be considered
 * @param {Array.<string>} [parameters.dependenciesRegExp] The dependencies to be considered as new
 *   RegExp instances
 * @param {boolean} [parameters.handleSubtree=false] Decides whether the sub-dependencies of the given
 *   dependencies are included into the returned dependency list
 * @returns {Array.<string|RegExp>} Array of the computed dependencies
 */
function createDependencyList({tree, dependencies = [], dependenciesRegExp = [], handleSubtree}) {
	const dependencyList = [];
	if (handleSubtree && dependenciesRegExp.length) {
		throw new Error("RegExp's should not be appended to list of sub-dependencies");
	}

	function _addUnique(depName) {
		if (!dependencyList.includes(depName)) {
			dependencyList.push(depName);
		}
	}
	function _findDependency(searchProject, depName) {
		let project = searchProject.dependencies.find((dep) => dep.metadata.name === depName);

		if (!project) {
			for (const project0 of searchProject.dependencies) {
				const result = _findDependency(project0, depName);
				if (result) {
					project = result;
					break;
				}
			}
		}

		return project;
	}
	function _processSubtree(project) {
		project.dependencies.forEach((project0) => {
			_addUnique(project0.metadata.name);
			_processSubtree(project0);
		});
	}

	dependencies.forEach((depName) => {
		if (depName === "*") {
			return _addUnique(depName);
		}
		const project = _findDependency(tree, depName);
		if (project) {
			_addUnique(depName);
			if (handleSubtree) {
				_processSubtree(project);
			}
		} else {
			log.warn(`Could not find dependency '${depName}' for '${tree.metadata.name}'.`);
		}
	});

	return dependencyList.concat(dependenciesRegExp.map((exp) => new RegExp(exp)));
}

/**
 * Merges a <code>dependencyList</code> into a <code>targetDependencyList</code> without duplicates. Values
 * given in <code>excludeList</code> are skipped.
 *
 * @param {Array.<string|RegExp>} targetDependencyList The target list
 * @param {Array.<string|RegExp>} dependencyList The source list
 * @param {Array.<string|RegExp>} excludeList The list of values to be excluded from the merge operation
 */
function mergeDependencyLists(targetDependencyList, dependencyList, excludeList) {
	function isInList(depList, depName) {
		return depList.some((dep) => dep instanceof RegExp ? dep.test(depName) : dep === depName);
	}
	function isRegExpInList(depList, depRegExp) {
		return depList.some((dep) => dep instanceof RegExp && dep.toString() === depRegExp.toString());
	}
	dependencyList.forEach((dep) => {
		if (
			dep instanceof RegExp && !isRegExpInList(targetDependencyList, dep) && !isRegExpInList(excludeList, dep) ||
			!(dep instanceof RegExp) && !targetDependencyList.includes(dep) && !isInList(excludeList, dep)
		) {
			targetDependencyList.push(dep);
		}
	});
}

/**
 * Returns whether project dependencies have to be built influenced by <code>includedDependencies</code> and
 * <code>excludedDependencies</code>.
 * If only selected dependencies (via <code>includedDependencies</code>) have to be built, the "*" character
 * is added to the <code>excludedDependencies</code> to make sure that all other dependencies are
 * excluded.
 * In case a "*" character is included in <code>includedDependencies</code>, it is removed and the
 * <code>buildAll</code> flag is set to <code>true</code> as it behaves as an alias.
 *
 * @param {boolean} buildAll The value of the <code>all</code> command line parameter to decide if project
 *   dependencies have to be built
 * @param {Array.<string|RegExp>} includedDependencies The list of included dependencies
 * @param {Array.<string|RegExp>} excludedDependencies The list of excluded dependencies
 * @returns {boolean} Whether it is required to build project dependencies
 */
function alignWithBuilderApi(buildAll, includedDependencies, excludedDependencies) {
	if ((!buildAll && !includedDependencies.includes("*")) && includedDependencies.length) {
		excludedDependencies.push("*");
	}
	if (includedDependencies.includes("*")) {
		buildAll = true;
		includedDependencies.splice(includedDependencies.indexOf("*"), 1);
	}
	if (!buildAll && includedDependencies.length) {
		buildAll = true;
	}
	return buildAll;
}

module.exports = {
	createDependencyList,
	mergeDependencyLists,
	alignWithBuilderApi
};
